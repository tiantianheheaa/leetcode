## 基本定义
1. **点**和**边**是构成图的2个基本元素。图是不同的点通过边连接起来的。
2. 有向图和无向图
   - 无向图：所有的边是双向的，即a->b同时b->a。
   - 有向图：边是单向的，a->b。但是b不一定->a。
3. 度
   - 顶点连接的边的数量。
   - 有向图：入度：顶点连接的到达本节点的边的数量。出度：从该顶点出去的边的数量。
4. 权值
   - 点权：每个点可能有自己的权重。【此时每个点的存储就不能是一个顶点号了，需要用结构体存储顶点号+权值。】
   - 边权：每个边有自己的权重。
5. **联通分量**：无向图中的**极大联通子图**。
   - 顶点联通：2个顶点之间相互联通。
   - 联通图：图中任意2个顶点都联通。
   - 极大联通子图：一个图中能联通的节点都包含到图中了。
6. 强联通分量：有向图中的**极大强联通子图**。
    - 顶点强联通：有向图中的2个顶点，可以互相到达对方。
    - 强联通图：图中任意2个顶点都强联通。
    - 极大强联通子图：图中能联通的节点都包含到图中了。
11. 

## 图的构建
1. 邻接矩阵
   - 例如图有n个节点，则矩阵的大小是n*2。arr[i][j]表示节点i到节点j 是否联通 / 联通权值。
   - 优点：方便。可以快速获得任意2个点是否联通。
   - 缺点：适用于稠密表，如果用于稀疏表，会有很多数组的空间用不到。
2. 邻接表
   - 例如图有n个节点。构建一维数组arr[n]。 数组的元素arr[i]是一个链表或数组，用来存储所有和节点i相连的节点。
   - 优点：节省内存空间，不浪费。
   - 缺点：不能快速得到2个节点是否联通，需要遍历。

## 图的遍历
1. 有dfs和bfs两种遍历方式，都可以。dfs写起来代码少一些。

### 200-岛屿数量
1. 思路：岛屿数量就是图的联通分量的数量。
   - 遍历图中的联通分量，每遍历一个联通分量，res+1。
   - 为了保证不重复遍历已遍历过的联通分量，所以需要对遍历过的节点做标记。
2. 易错点：dfs的**边界条件很多容易遗漏**。（1）先判断坐标是否在图内。（2）水是边界。（3）陆地不能被访问过。
```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        if(m == 0) return 0;
        int n = grid[0].size();
        if(n == 0) return 0;
        // 不改变原二维数组的值，需要额外一个二维数组来表示节点是否访问过
        vector<vector<int>> flag(m, vector<int>(n, 0));
        int res = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                // 陆地，并且该节点没有被访问过，则是一个dfs的起点
                if(grid[i][j] == '1' && flag[i][j] == 0){
                    dfs(i, j, m, n, grid, flag);
                    res++;
                }
            }
        }
        return res;
    }
    void dfs(int i, int j, int m, int n, vector<vector<char>>& grid, vector<vector<int>>& flag){
        // 递归边界
        // 递归边界有很多种情况：哪一样都不能少。（1）先判断坐标i和j是否在边界内，保证后面的grid[i][j]和flag[i][j]有效。（2）水是边界，grid[i][j]=='0' (3)已访问过的陆地 不能再次访问，也是边界。flag[i][j]==1
        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0' || flag[i][j] == 1){
            return;
        }
        // 没有访问过的陆地节点，标记已访问过。
        flag[i][j] = 1;
        dfs(i+1, j, m, n, grid, flag);
        dfs(i-1, j, m, n, grid, flag);
        dfs(i, j+1, m, n, grid, flag);
        dfs(i, j-1, m, n, grid, flag);
    }
};
// dfs
// 联通分量的个数
```


## 
