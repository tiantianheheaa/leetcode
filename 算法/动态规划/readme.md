## 算法思想
1. **分治**是解决问题的一个重要思想，分治后可以利用计算机的计算能力，求解原问题。
2. 相同点：递归和动态规划都是分治的思想。都需要将原问题分解子问题。
3. 区别：动态规划直接递推，省去了递归分解子问题的过程。
- 递归：自上向下的分解到最小的子问题 - 求解最小子问题 - 自下向上回溯求解原问题。
- 动态规划：直接从最小的子问题 自下向上的递推求解 原问题。
- 综上，二者都是自下向上 从子问题逐步求解原问题。
## 代码模版
1. dp数组的定义和初始化。
2. dp数组的填充（涉及填充顺序）。
## 典型题目
### 一维dp
1. 509-斐波那契数列。
- 一个典型的入门题，题目直接给出了dp数组的定义、初始化和递推公式。 直接for循环填充dp数组即可得到答案。
2. 70-爬楼梯
- 比第一题的入门题，更进一步。这个题目需要自己分解子问题，从而找出递推公式。而没有直接给出。
3. 746-使用最小花费爬楼梯
- 在第2题的基础上，除了需要自己分解子问题。还需要自己想dp数组的定义。
- dp数组的定义**和题目是息息相关**的。例如题目问的是“最小花费”而不是“花费”，所以dp数组需要定义为“最小花费”，并且通过min来求解。
- dp数组的初始化**和题目是息息相关**的。因为题目中爬到第0个台阶、第1个台阶是不需要花费的，因此dp[0]和dp[1]初始化为0。在第0个、第1个台阶向上爬，才需要cost[0]、cost[1]的花费。
4. 343-整数拆分
- 一维dp。但是dp[i]需要for循环遍历才能求出最大值。有点像最长子序列的问题。
- 递推公式容易遗漏条件：dp[i]是一定被拆分过的，k>=2表示至少是2个数的乘积。j*dp[i-j]中的dp[i-j]至少是2个数的乘积，所以j *dp[i-j] 至少是3个数的乘积。忽略了j *（i-j）这种情况。 因此求出的dp[i]不是最大值。
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1, 0);
        dp[1] = 1;

        for(int i = 2; i < n+1; i++){
            for(int j = 1; j < i; j++){
                // 从遍历开始，j=1，表示i一定被拆分。
                // j*(i-j)容易被遗漏
                dp[i] = max(max(dp[i], j * (i-j)), j * dp[i-j]);
            }
        }
        return dp[n];
    }
};
// dp[n]表示最大乘积。dp[n]
// 递推公式：dp[i] = max(dp[i], j*dp[i-j])。 
    // 这个递归公式不是最大值的原因是，少了一种情况。就是(i-j)不被拆分的情况。
// 因为dp[i]的含义是一定被拆分过的，因为k>=2。
// 上述递推公式中，没有考虑不拆分的情况。应该是dp[i]，j*dp[i-j], j*(i-j)三者之间取max。
```
5. 96-不同的二叉搜索树
- 思路：分治的思想很重要，二叉树的题目，自然的想到用分治。 因为二叉搜索树的定义也是：左子树的值<=根节点，右子树的值>根节点，且左子树和右子树叶是二叉搜索树。从定义看，也是递归的。
- 递推的思路：
    - 先把1个节点的BST数量，2个节点的BST数量，情况比较少，可以直接画图得到。
    - 3个节点的BST数量，就可以用分治的思想，根节点占用1个节点，左子树和右子树一共分2个节点，且左子树和右子树的结果直接用dp[1]和dp[2]得到。
    - 类似的，4个节点的BST数量，用分治的思想，左子树和右子树一共分3个节点，... 这是一个**典型的递推过程**。
<img width="494" height="562" alt="image" src="https://github.com/user-attachments/assets/9727519a-7d7f-49c3-82a9-e72c476347bd" />

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        if(n == 1) return dp[1];
        dp[2] = 2;
        // 写出dp[1]和dp[2]，然后画图dp[3]，就可以找到递推规律了。
        for(int i = 3; i < n+1; i++){
            for(int j = 0; j <= i-1; j++){
                dp[i] = dp[i] + dp[j]*dp[i-1-j];
            }
        }
        return dp[n];
    }
};
// BST的定义是：左子树小于根节点，右子树大于根节点。
// 确实可以通过递归或递推来分解子问题（思考思路）。
// 没想到是自己通过画图递推得到的递推公式（有了结果）。
// 递推的含义就在于，自己从0、1、2、...开始枚举，找规律。从而得到递推公式。
```

### 二维dp
1. 62-不同路径
- 二维dp的入门题目。 需要注意二维数组的初始化，dp数组的初始化（初始化(0,0)位置和一行一列），dp数组的填充(填充(1,1)位置及其右下角)。
- 二维dp数组的填充顺序：这个题目逐行、逐列填充都可以。**原则**是dp[i][j]=dp[i-1][j]+dp[i][j-1]，保证计算dp[i][j]时，dp[i-1][j]和dp[i][j-1]已经计算好结果。
- debug：遇到结果不符合预期，debug。 保持冷静，思路一定是正确的。就是保持代码执行细节 和 自己心里的思路是一致的即可。

2. 63-不同路径2
- 递推公式：所有递推公式加了if...else...判断。有障碍物，由于障碍物的地方不能到达，所以dp[i][j]=0。否则，dp[i][j]=dp[i-1][j]+dp[i][j-1]。
- **一行一列的递推公式**：初始化dp数组的第一行和第一列，不能直接赋值1，在没有障碍物的情况下可以。 但是由于有障碍物，所以需要dp[i][0]=dp[i-1][0] 和 dp[0][j]=dp[0][j-1]来初始化。
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = 1;
        if(obstacleGrid[0][0] == 1){
            dp[0][0] = 0;
        }
        for(int i = 1; i < m; i++){
            // 注意一行、一列的初始化的 递推公式dp[i][0] = dp[i-1][0]。也是递推出来的，不是直接赋值1。
            dp[i][0] = dp[i-1][0];
            if(obstacleGrid[i][0] == 1){  // if...else...逻辑判断
                dp[i][0] = 0;
            } 
        }
        for(int j = 1; j < n; j++){
            // 注意递推公式dp[0][j] = dp[0][j-1]
            dp[0][j] = dp[0][j-1];
            if(obstacleGrid[0][j] == 1){  // if...else...逻辑判断
                dp[0][j] = 0;
            }
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i][j-1] + dp[i-1][j];
                if(obstacleGrid[i][j] == 1){  // if...else...逻辑判断
                    dp[i][j] = 0;
                }
            }
        }
        return dp[m-1][n-1];
    }
};
// 在62-不同路径的基础上，增加了障碍物。
// 如果grid[i][j]=1，表示有障碍物，不能到达这个位置，则dp[i][j]=0。 否则，dp[i][j]=dp[i-1][j]+dp[i][j-1]。
// 注意：一行、一列的初始化，也是递推公式。 不是直接赋值0（没有障碍物的情况下，可以直接赋值1）。
```
### 背包问题
### 打家劫舍问题
### 股票问题
### 子序列问题
