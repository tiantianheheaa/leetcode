## 算法思想
1. **分治**是解决问题的一个重要思想，分治后可以利用计算机的计算能力，求解原问题。
2. 相同点：递归和动态规划都是分治的思想。都需要将原问题分解子问题。
3. 区别：动态规划直接递推，省去了递归分解子问题的过程。
- 递归：自上向下的分解到最小的子问题 - 求解最小子问题 - 自下向上回溯求解原问题。
- 动态规划：直接从最小的子问题 自下向上的递推求解 原问题。
- 综上，二者都是自下向上 从子问题逐步求解原问题。
## 代码模版
1. dp数组的定义和初始化。
2. dp数组的填充（涉及填充顺序）。
## 典型题目
### 一维dp
1. 509-斐波那契数列。
- 一个典型的入门题，题目直接给出了dp数组的定义、初始化和递推公式。 直接for循环填充dp数组即可得到答案。
2. 70-爬楼梯
- 比第一题的入门题，更进一步。这个题目需要自己分解子问题，从而找出递推公式。而没有直接给出。
3. 746-使用最小花费爬楼梯
- 在第2题的基础上，除了需要自己分解子问题。还需要自己想dp数组的定义。
- dp数组的定义**和题目是息息相关**的。例如题目问的是“最小花费”而不是“花费”，所以dp数组需要定义为“最小花费”，并且通过min来求解。
- dp数组的初始化**和题目是息息相关**的。因为题目中爬到第0个台阶、第1个台阶是不需要花费的，因此dp[0]和dp[1]初始化为0。在第0个、第1个台阶向上爬，才需要cost[0]、cost[1]的花费。
4. 343-整数拆分
- 一维dp。但是dp[i]需要for循环遍历才能求出最大值。有点像最长子序列的问题。
- 递推公式容易遗漏条件：dp[i]是一定被拆分过的，k>=2表示至少是2个数的乘积。j*dp[i-j]中的dp[i-j]至少是2个数的乘积，所以j *dp[i-j] 至少是3个数的乘积。忽略了j *（i-j）这种情况。 因此求出的dp[i]不是最大值。
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1, 0);
        dp[1] = 1;

        for(int i = 2; i < n+1; i++){
            for(int j = 1; j < i; j++){
                // 从遍历开始，j=1，表示i一定被拆分。
                // j*(i-j)容易被遗漏
                dp[i] = max(max(dp[i], j * (i-j)), j * dp[i-j]);
            }
        }
        return dp[n];
    }
};
// dp[n]表示最大乘积。dp[n]
// 递推公式：dp[i] = max(dp[i], j*dp[i-j])。 
    // 这个递归公式不是最大值的原因是，少了一种情况。就是(i-j)不被拆分的情况。
// 因为dp[i]的含义是一定被拆分过的，因为k>=2。
// 上述递推公式中，没有考虑不拆分的情况。应该是dp[i]，j*dp[i-j], j*(i-j)三者之间取max。
```
5. 96-不同的二叉搜索树
- 思路：分治的思想很重要，二叉树的题目，自然的想到用分治。 因为二叉搜索树的定义也是：左子树的值<=根节点，右子树的值>根节点，且左子树和右子树叶是二叉搜索树。从定义看，也是递归的。
- 递推的思路：
    - 先把1个节点的BST数量，2个节点的BST数量，情况比较少，可以直接画图得到。
    - 3个节点的BST数量，就可以用分治的思想，根节点占用1个节点，左子树和右子树一共分2个节点，且左子树和右子树的结果直接用dp[1]和dp[2]得到。
    - 类似的，4个节点的BST数量，用分治的思想，左子树和右子树一共分3个节点，... 这是一个**典型的递推过程**。
<img width="494" height="562" alt="image" src="https://github.com/user-attachments/assets/9727519a-7d7f-49c3-82a9-e72c476347bd" />

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        if(n == 1) return dp[1];
        dp[2] = 2;
        // 写出dp[1]和dp[2]，然后画图dp[3]，就可以找到递推规律了。
        for(int i = 3; i < n+1; i++){
            for(int j = 0; j <= i-1; j++){
                dp[i] = dp[i] + dp[j]*dp[i-1-j];
            }
        }
        return dp[n];
    }
};
// BST的定义是：左子树小于根节点，右子树大于根节点。
// 确实可以通过递归或递推来分解子问题（思考思路）。
// 没想到是自己通过画图递推得到的递推公式（有了结果）。
// 递推的含义就在于，自己从0、1、2、...开始枚举，找规律。从而得到递推公式。
```

### 二维dp
1. 62-不同路径
- 二维dp的入门题目。 需要注意二维数组的初始化，dp数组的初始化（初始化(0,0)位置和一行一列），dp数组的填充(填充(1,1)位置及其右下角)。
- 二维dp数组的填充顺序：这个题目逐行、逐列填充都可以。**原则**是dp[i][j]=dp[i-1][j]+dp[i][j-1]，保证计算dp[i][j]时，dp[i-1][j]和dp[i][j-1]已经计算好结果。
- debug：遇到结果不符合预期，debug。 保持冷静，思路一定是正确的。就是保持代码执行细节 和 自己心里的思路是一致的即可。

2. 63-不同路径2
- 递推公式：所有递推公式加了if...else...判断。有障碍物，由于障碍物的地方不能到达，所以dp[i][j]=0。否则，dp[i][j]=dp[i-1][j]+dp[i][j-1]。
- **一行一列的递推公式**：初始化dp数组的第一行和第一列，不能直接赋值1，在没有障碍物的情况下可以。 但是由于有障碍物，所以需要dp[i][0]=dp[i-1][0] 和 dp[0][j]=dp[0][j-1]来初始化。
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = 1;
        if(obstacleGrid[0][0] == 1){
            dp[0][0] = 0;
        }
        for(int i = 1; i < m; i++){
            // 注意一行、一列的初始化的 递推公式dp[i][0] = dp[i-1][0]。也是递推出来的，不是直接赋值1。
            dp[i][0] = dp[i-1][0];
            if(obstacleGrid[i][0] == 1){  // if...else...逻辑判断
                dp[i][0] = 0;
            } 
        }
        for(int j = 1; j < n; j++){
            // 注意递推公式dp[0][j] = dp[0][j-1]
            dp[0][j] = dp[0][j-1];
            if(obstacleGrid[0][j] == 1){  // if...else...逻辑判断
                dp[0][j] = 0;
            }
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i][j-1] + dp[i-1][j];
                if(obstacleGrid[i][j] == 1){  // if...else...逻辑判断
                    dp[i][j] = 0;
                }
            }
        }
        return dp[m-1][n-1];
    }
};
// 在62-不同路径的基础上，增加了障碍物。
// 如果grid[i][j]=1，表示有障碍物，不能到达这个位置，则dp[i][j]=0。 否则，dp[i][j]=dp[i-1][j]+dp[i][j-1]。
// 注意：一行、一列的初始化，也是递推公式。 不是直接赋值0（没有障碍物的情况下，可以直接赋值1）。
```
### 背包问题
### 打家劫舍问题
### 股票问题
### 子序列问题
1. 300-最长递增子序列
- 一维dp。
- 递增子序列，可以不连接。所以最长递增子序列有**很大的不确定性**，首尾元素不确定，可能是由于数组中间的几个元素构成的。 无法直接通过dp数组求解最终的问题。
- dp数组的定义：dp[i]表示以nums[i]结尾的最长递增子序列。**通过增加确定性使得问题可解（可用动态规划的方式来解），来求解一个间接的、和最终问题有关系的问题。 相当于分治的思路求解最终问题。**
- 最终的问题和dp数组的关系：遍历dp数组中的最大值，就是最终问题的解。
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;  // 处理边界情况
        vector<int> dp(n, 0);
        dp[0] = 1;
        if(n == 1) return 1;  // 处理边界情况
        for(int i = 1; i < n; i++){
            // 初始化自身，一个元素
            dp[i] = 1;
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){  // 严格递增
                    // nums[i]这1个元素 接到dp[j]最长子序列后面
                    dp[i] = max(dp[i], dp[j]+1);
                }
            }
        }
        // 最终结果，就是遍历dp数组，求解最大值
        int res = dp[0];
        for(int i = 1; i < n; i++){
            res = max(res, dp[i]);
        }
        return res;
    }
};
// 子序列 不连续。
// 由于最长递增子序列的首尾是不确定的，可能由数组中间的某几个元素组成。所以dp数组不能直接求解最终的问题。 dp数组可以求解一个间接的、更确定性的问题。
// dp[i]表示以nums[i]结尾的最长递增子序列的长度。  增加了确定性：以nums[i]结尾。 dp[i]求解问题 和 题目问题的关系：遍历dp数组，就是题目问题的解。
// 递推公式：dp[i]的初始化是其本身。 dp[i]可以接dp[j](j<i)的结果来构成最长递增子序列。
// 一维dp问题。递推公式需要for循环遍历来求解最优值。
```
2. 674-最长连续递增子序列
- 一维dp。
- 最长连续递增子序列 比 不连续的，更简单。dp数组的求解不用for循环，更简单。
- 由于这个题目比较简单，所有有更多的解法。本题目的**空间复杂度O(1)优化**解法：（1）dp的基础上，优化空间复杂度。不用dp数组，用pre变量。（2）双指针。（3）贪心。

3. 53-最大子数组和
- 一维dp。连续。
- 因为**子数组的首尾是不确定的**，可能是数组中间的几个连续元素组成的。 **由于不确定性，所以无法判断连续性**。
- **通过增加确定性，使得问题可解**，将dp数组定义为以nums[i]结尾的子数组的最大和。从而可以根据连续性，求得dp数组的递推公式，使得问题可解。
- 题目的问题：通过遍历dp数组的最大值，得到最终问题的解。
- 本题的**不同解法**：（1）dp。（2）dp+优化空间复杂度。（3）贪心。
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        // 不能初始化为0，因为有的数是负数，比0小。所以下面需要重新初始化。
        vector<int> dp(n, 0);
        dp[0] = nums[0];
        for(int i = 1; i < n; i++){
            // 因为连续，要么是自身一个数值，要么连接dp[i-1]。因为dp[i-1]是以nums[i-1]结尾的子序列的最大和。
            dp[i] = nums[i];
            if(dp[i-1] > 0){
                dp[i] = dp[i] + dp[i-1];
            }
        }
        // 最终问题的解
        int res = dp[0];
        for(int i = 1; i < n; i++){
            res = max(res, dp[i]);
        }
        return res;
    }
};
// 最大连续子数组和 (leetcode喜欢用数组表示连续，因为数组的内存是连续的)
// 因为要求连续，所以dp[i]表示以nums[i]结尾的 最大连续子数组的和。 要么是自身，要么只能连接dp[i-1]。
// 问题最终的解：遍历dp数组，求最大值。
```

4. 1143-最长公共子序列
- 二维dp。 不连续。
- 上面二维dp的入门题目（不同路径）是非常有用的，给了**二维dp的模版**。 这道题基本就用二维dp的模版就可以了。  dp数组的初始化和填充：初始化(0,0)，初始化一行和一列，从(1,1)位置开始填充。
- 最核心的是递推公式。**递推公式决定了初始化**（例如需要i-1和j-1，就需要初始化第一行和第一列），**决定了dp数组的填充顺序**（例如需要i-1和j-1，就需要从左上角向右下角的方向遍历填充）。
- dp数组的定义：dp[i][j]表示 text1[0:i]和text2[0:j]这两个序列的最长公共子序列，包含text1[i]和text2[j]，但是最长公共子序列不一定以text1[i]或text2[j]结尾，这也是不确定性的存在。
- 递推公式：dp[i][j]可以从三个位置到达：左边、上边、左上角。
    - dp[i][j]=max(dp[i-1][j], dp[i][j-1]); if(text1[i]==text2[j]) dp[i][j]=max(dp[i][j], dp[i-1][j-1]+1);
    - 先在dp[i-1][j], dp[i][j-1] 二者中取最大值，因为dp[i-1][j-1]一定小于等于dp[i-1][j], dp[i][j-1]，比他们少一个元素。
    - 然后如果text1[i]==text2[j]，就可以在dp[i-1][j-1]的基础上+1。 因此可以用dp[i-1][j-1]+1 更新dp[i][j]。
- **容易出错的地方**：（1）一行一列的初始化，容易下意识的赋值0或1。其实**应该用递推公式继承**dp[i-1][0]。（2）递推公式：3条路径中取max。逻辑关系要搞清楚。
```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        if(m == 0 || n == 0) return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        // 初始化
        if(text1[0] == text2[0]){
            dp[0][0] = 1;
        }else{
            dp[0][0] = 0;
        }
        // 二维dp, 初始化一行、一列，最容易出错。 不能下意识的赋值为0或1。
        for(int i = 1; i < m; i++){
            if(text1[i] == text2[0]){
                dp[i][0] = 1;
            }else{
                dp[i][0] = dp[i-1][0];  // 是继承。因为text1[i] != text2[0]，可能text1[j](j<i) == text2[0]，所以这个关系需要一路继承过来。
            }
        }
        for(int j = 1; j < n; j++){
            if(text1[0] == text2[j]){
                dp[0][j] = 1;
            }else{
                dp[0][j] = dp[0][j-1];  // 需要继承。
            }
        }
        // 从(1,1)位置开始填充
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                // dp[i-1][j-1]的值是小于等于dp[i-1][j], dp[i][j-1]的。所以先从dp[i-1][j], dp[i][j-1]中取最大值。
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                // 如果text1[i] == text2[j]，再用dp[i-1][j-1] + 1更新。
                if(text1[i] == text2[j]){
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1);
                }
            }
        }
        return dp[m-1][n-1];
    }
};
// 二维dp
// 子序列是可以连续，可以不连续。 因为可以不连续，所以可以状态转移。
// dp数组的定义：dp[i][j] 表示text1[0:i] 和 text[0:j] 两个字符串的最长公共子序列。 不一定为text1[i], text2[j]结尾。
// 递推公式：dp[i][j] = dp[i][j-1], dp[i-1][j], dp[i-1][j-1] 三者中的最大值。 如果text1[i]==text2[j]，则dp[i-1][j-1] + 1。
// 由于dp[i][j-1], dp[i-1][j]的结果 一定是大于等于dp[i-1][j-1]的。所以先取dp[i][j-1], dp[i-1][j]二者中的最大值就可以。如果text1[i]==text2[j]，再用dp[i-1][j-1]+1来更新。

// 整体思路没有问题。 有2个细节出错：（1）一行一列的递推公式，还是下意识的0和1，是错误的。是需要递推的。（2）dp[i][j]是三个值取max。如果第二次取max，遗漏了dp[i][j]，就不是更新了。
```
5. 718-最长公共子序列（连续）
- 二维dp，连续。
- **子序列（连续） 不一定比 子序列（非连续）简单**。 因为**二者解决的是不同的问题**。 例如这个题目需要修改dp数组的定义，而且无法通过dp数组直接求解最终问题的解。
- dp数组的定义：
    - 公共子序列(非连续)中dp数组的定义是dp[i][j]是text1[0:i]和text1[0:j]的最长公共子序列的长度，但是**不一定是以text1[i]和text2[j]结尾的，而且不知道是以哪个元素结尾的，具有不确定性，从而无法判断公共子序列的连续性**。
    - 为了能判断公共子序列的连续性，**通过修改dp数组的定义来降低不确定性，使得连续公共子序列可解**。因此dp数组定义为：dp[i][j]表示以text1[i]和text2[j]结尾的最长公共子序列的长度。
- 递推公式
    - 一行一列的初始化：if(text1[i]==text2[0]) dp[i][0] = 1; else dp[i][0] = 0;  因为text2[0]只有这一个元素，而且以它结尾。所以如果不相等，dp数组就直接等于0，不用继承dp[i-1][0]了。
    - 从(1,1)位置开始填充：if(text1[i] == text2[j]) dp[i][j] = dp[i-1][j-1] + 1; 否则 dp[i][j] = 0; 因为以text1[i]和text2[j]结尾，所以如果这2个元素不等，dp数组就是0。如果这2个元素相等，只能继承dp[i-1][j-1]，因为它是以text1[i-1]和text2[j-1]结尾的公共子序列，加上text1[i]和text2[j]可以保证连续。
```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        if(m == 0 || n == 0) return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        if(nums1[0] == nums2[0]){
            dp[0][0] = 1;
        }else{
            dp[0][0] = 0;
        }
        for(int i = 1; i < m; i++){
            if(nums1[i] == nums2[0]){
                dp[i][0] = 1;
            }else{
                dp[i][0] = 0;  // 不能继承dp[i-1][0]，因为一定是以text1[i]和text2[0]结尾的公共子序列。
            }
        }
        for(int j = 1; j < n; j++){
            if(nums1[0] == nums2[j]){
                dp[0][j] = 1;
            }else{
                dp[0][j] = 0;
            }
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                if(nums1[i] == nums2[j]){
                    // 由于是以text1[i]和text2[j]结尾，所以只能从dp[i-1][j-1]来递推，因为dp[i-1][j-1]是以text1[i-1]和text2[j-1]结尾的，从而可以保证公共子序列连续。
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = 0;  // 不写这个也可以，因为已经初始化为0
                }
                
            }
        }
        // 这个题目的解，遍历所有以text1[i]和text2[j]结尾的公共子序列，找到最大值。
        int res = dp[0][0];
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};
// 子数组是连续的。
// 最开始的思路：还是最长公共子序列（非连续）的模版。
// dp数组的定义会变化：最长公共子序列（非连续）中dp数组的定义，dp[i][j]不一定以text1[i]和text2[j]结尾，而且不知道是以哪个元素结尾。 但是由于【连续】的要求，一定需要知道是以哪个元素结尾的。
// 所以dp数组的定义为dp[i][j]是以text1[i]和text2[j]结尾的最长公共子序列的长度。
// 由于是以text1[i]和text2[j]结尾，所以递推公式会更简单一些。
// 这个问题的解：遍历dp数组，求最大值。
```
