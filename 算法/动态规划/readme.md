## 算法思想
1. **分治**是解决问题的一个重要思想，分治后可以利用计算机的计算能力，求解原问题。
2. 相同点：递归和动态规划都是分治的思想。都需要将原问题分解子问题。
3. 区别：动态规划直接递推，省去了递归分解子问题的过程。
- 递归：自上向下的分解到最小的子问题 - 求解最小子问题 - 自下向上回溯求解原问题。
- 动态规划：直接从最小的子问题 自下向上的递推求解 原问题。
- 综上，二者都是自下向上 从子问题逐步求解原问题。
## 代码模版
1. dp数组的定义和初始化。
2. dp数组的填充（涉及填充顺序）。
## 典型题目
### 一维dp
1. 509-斐波那契数列。
- 一个典型的入门题，题目直接给出了dp数组的定义、初始化和递推公式。 直接for循环填充dp数组即可得到答案。
2. 70-爬楼梯
- 比第一题的入门题，更进一步。这个题目需要自己分解子问题，从而找出递推公式。而没有直接给出。
3. 746-使用最小花费爬楼梯
- 在第2题的基础上，除了需要自己分解子问题。还需要自己想dp数组的定义。
- dp数组的定义**和题目是息息相关**的。例如题目问的是“最小花费”而不是“花费”，所以dp数组需要定义为“最小花费”，并且通过min来求解。
- dp数组的初始化**和题目是息息相关**的。因为题目中爬到第0个台阶、第1个台阶是不需要花费的，因此dp[0]和dp[1]初始化为0。在第0个、第1个台阶向上爬，才需要cost[0]、cost[1]的花费。
### 二维dp
1. 62-不同路径
- 二维dp的入门题目。 需要注意二维数组的初始化，dp数组的初始化（初始化(0,0)位置和一行一列），dp数组的填充(填充(1,1)位置及其右下角)。
- 二维dp数组的填充顺序：这个题目逐行、逐列填充都可以。**原则**是dp[i][j]=dp[i-1][j]+dp[i][j-1]，保证计算dp[i][j]时，dp[i-1][j]和dp[i][j-1]已经计算好结果。
- debug：遇到结果不符合预期，debug。 保持冷静，思路一定是正确的。就是保持代码执行细节 和 自己心里的思路是一致的即可。

2. 63-不同路径2
- 递推公式：所有递推公式加了if...else...判断。有障碍物，由于障碍物的地方不能到达，所以dp[i][j]=0。否则，dp[i][j]=dp[i-1][j]+dp[i][j-1]。
- **一行一列的递推公式**：初始化dp数组的第一行和第一列，不能直接赋值1，在没有障碍物的情况下可以。 但是由于有障碍物，所以需要dp[i][0]=dp[i-1][0] 和 dp[0][j]=dp[0][j-1]来初始化。
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        if(m == 0) return 0;
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = 1;
        if(obstacleGrid[0][0] == 1){
            dp[0][0] = 0;
        }
        for(int i = 1; i < m; i++){
            // 注意一行、一列的初始化的 递推公式dp[i][0] = dp[i-1][0]。也是递推出来的，不是直接赋值1。
            dp[i][0] = dp[i-1][0];
            if(obstacleGrid[i][0] == 1){  // if...else...逻辑判断
                dp[i][0] = 0;
            } 
        }
        for(int j = 1; j < n; j++){
            // 注意递推公式dp[0][j] = dp[0][j-1]
            dp[0][j] = dp[0][j-1];
            if(obstacleGrid[0][j] == 1){  // if...else...逻辑判断
                dp[0][j] = 0;
            }
        }
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[i][j] = dp[i][j-1] + dp[i-1][j];
                if(obstacleGrid[i][j] == 1){  // if...else...逻辑判断
                    dp[i][j] = 0;
                }
            }
        }
        return dp[m-1][n-1];
    }
};
// 在62-不同路径的基础上，增加了障碍物。
// 如果grid[i][j]=1，表示有障碍物，不能到达这个位置，则dp[i][j]=0。 否则，dp[i][j]=dp[i-1][j]+dp[i][j-1]。
// 注意：一行、一列的初始化，也是递推公式。 不是直接赋值0（没有障碍物的情况下，可以直接赋值1）。
```
### 背包问题
### 打家劫舍问题
### 股票问题
### 子序列问题
