在 C++ 中，**递归函数（Recursive Function）** 是直接或间接调用自身的函数。递归是一种强大的编程技术，适用于解决可以被分解为相似子问题的问题（如分治、树形结构遍历等）。

---

## **1. 递归函数的定义**
递归函数必须满足两个关键条件：
1. **基准条件（Base Case）**：递归终止的条件，防止无限递归。
2. **递归条件（Recursive Case）**：函数调用自身，逐步向基准条件靠近。

### **语法模板**
```cpp
return_type recursiveFunction(parameters) {
    // 1. 基准条件（终止条件）
    if (base_case_condition) {
        return base_case_value;
    }
    // 2. 递归条件（调用自身）
    else {
        // 可能包含问题规模缩减的操作
        return recursiveFunction(reduced_problem);
    }
}
```

---

## **2. 递归函数的用法**
### **示例 1：计算阶乘（Factorial）**
```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    // 基准条件：0! = 1
    if (n == 0) {
        return 1;
    }
    // 递归条件：n! = n * (n-1)!
    else {
        return n * factorial(n - 1);
    }
}

int main() {
    cout << factorial(5); // 输出 120 (5! = 5*4*3*2*1 = 120)
    return 0;
}
```

### **示例 2：斐波那契数列（Fibonacci）**
```cpp
int fibonacci(int n) {
    // 基准条件
    if (n <= 1) {
        return n;
    }
    // 递归条件：fib(n) = fib(n-1) + fib(n-2)
    else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    cout << fibonacci(6); // 输出 8 (0,1,1,2,3,5,8)
    return 0;
}
```

---

## **3. 递归函数的优缺点**
### **优点**
1. **代码简洁**：递归解决方案通常比迭代更直观（如树遍历、分治问题）。
2. **适合分治问题**：如快速排序、归并排序、汉诺塔等。

### **缺点**
1. **性能开销**：每次递归调用都会生成新的栈帧，可能引发栈溢出（Stack Overflow）。
2. **重复计算**：如斐波那契数列的朴素递归会重复计算子问题（可用动态规划优化）。
3. **调试困难**：递归调用链可能难以追踪。

---

## **4. 递归的使用场景**
1. **树和图的遍历**：
   - 前序、中序、后序遍历（二叉树）。
   - 深度优先搜索（DFS）。
2. **分治算法**：
   - 快速排序、归并排序。
   - 二分查找。
3. **数学问题**：
   - 阶乘、斐波那契数列、组合数（C(n, k)）。
4. **回溯问题**：
   - 八皇后、全排列、数独求解。
5. **动态规划**：
   - 某些问题（如背包问题）的递归形式可优化为记忆化搜索。

---

## **5. 递归的优化与注意事项**
### **(1) 尾递归优化**
如果递归调用是函数的最后一步操作，编译器可能优化为迭代（避免栈溢出）：
```cpp
// 尾递归示例（计算阶乘）
int factorial(int n, int acc = 1) {
    if (n == 0) return acc;
    return factorial(n - 1, n * acc); // 尾递归
}
```

### **(2) 避免重复计算**
斐波那契数列的递归效率低（O(2^n)），可用记忆化（Memoization）优化：
```cpp
#include <unordered_map>
unordered_map<int, int> memo;

int fibonacci(int n) {
    if (n <= 1) return n;
    if (memo.find(n) == memo.end()) {
        memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
    }
    return memo[n];
}
```

### **(3) 递归转迭代**
某些递归问题可用栈模拟递归过程（避免栈溢出）：
```cpp
// 迭代版阶乘
int factorialIterative(int n) {
    int result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}
```

---

## **6. 经典递归问题代码模板**
### **(1) 二分查找（递归版）**
```cpp
int binarySearch(vector<int>& nums, int target, int left, int right) {
    if (left > right) return -1; // 基准条件
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) return mid;
    else if (nums[mid] < target) {
        return binarySearch(nums, target, mid + 1, right);
    } else {
        return binarySearch(nums, target, left, mid - 1);
    }
}
```

### **(2) 快速排序（递归版）**
```cpp
int partition(vector<int>& nums, int low, int high) {
    int pivot = nums[high];
    int i = low - 1;
    for (int j = low; j < high; ++j) {
        if (nums[j] <= pivot) {
            swap(nums[++i], nums[j]);
        }
    }
    swap(nums[i + 1], nums[high]);
    return i + 1;
}

void quickSort(vector<int>& nums, int low, int high) {
    if (low < high) {
        int pi = partition(nums, low, high);
        quickSort(nums, low, pi - 1);
        quickSort(nums, pi + 1, high);
    }
}
```

### **(3) 汉诺塔（Tower of Hanoi）**
```cpp
void hanoi(int n, char from, char to, char aux) {
    if (n == 1) {
        cout << "Move disk 1 from " << from << " to " << to << endl;
        return;
    }
    hanoi(n - 1, from, aux, to);
    cout << "Move disk " << n << " from " << from << " to " << to << endl;
    hanoi(n - 1, aux, to, from);
}
```

---

## **7. 总结**
| **特性**               | **说明**                                                                 |
|------------------------|--------------------------------------------------------------------------|
| **基准条件**           | 必须存在，否则递归无限进行（栈溢出）。                                   |
| **递归条件**           | 问题规模逐步缩小，趋向基准条件。                                         |
| **性能**               | 可能因重复计算或栈深度导致效率问题，需谨慎使用。                         |
| **适用场景**           | 分治、树形结构、回溯、数学归纳问题。                                     |
| **优化方法**           | 尾递归、记忆化、递归转迭代。                                             |

递归是解决特定问题的利器，但需权衡可读性与性能。在面试或竞赛中，递归常用于快速实现算法原型，但实际工程中可能需要优化为迭代或动态规划。
