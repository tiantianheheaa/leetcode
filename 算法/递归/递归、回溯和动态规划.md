递归、动态规划、回溯是三种基于递归思想的算法，它们在问题分解、重复计算处理、解空间搜索等方面存在差异，以下是详细分析：

### **一、算法思想对比**

| **算法**   | **核心思想**                                                                 | **关键点**                                                                 |
|------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| **递归**   | 直接或间接调用自身，将问题分解为同类子问题。                                | 1. 基准条件（终止递归）<br>2. 递归条件（问题规模缩小）                     |
| **动态规划** | 分解为重叠子问题，存储子问题解避免重复计算，通过状态转移方程推导全局最优解。 | 1. 最优子结构<br>2. 重叠子问题<br>3. 状态转移方程<br>4. 记忆化（自顶向下）或填表（自底向上） |
| **回溯**   | 通过递归遍历解空间树，利用剪枝优化搜索效率。                                | 1. 解空间树（如排列、组合、子集）<br>2. 剪枝（跳过无效分支）<br>3. 撤销选择（回溯） |

### **二、代码模板对比**

#### **1. 递归模板**
```cpp
return_type recursiveFunction(parameters) {
    // 基准条件（终止递归）
    if (base_case_condition) {
        return base_case_value;
    }
    // 递归条件（问题规模缩小）
    else {
        return recursiveFunction(reduced_parameters);
    }
}
```
**示例：阶乘**
```cpp
int factorial(int n) {
    if (n == 0) return 1; // 基准条件
    return n * factorial(n - 1); // 递归条件
}
```

#### **2. 动态规划模板**
**自顶向下（递归+记忆化）**
```cpp
unordered_map<int, int> memo; // 存储子问题解

int dp(int n) {
    if (n <= 1) return n; // 基准条件
    if (memo.find(n) != memo.end()) return memo[n]; // 查表
    memo[n] = dp(n - 1) + dp(n - 2); // 递归+存储
    return memo[n];
}
```
**自底向上（迭代填表）**
```cpp
int dp(int n) {
    if (n <= 1) return n;
    vector<int> table(n + 1);
    table[0] = 0; table[1] = 1; // 初始化
    for (int i = 2; i <= n; ++i) {
        table[i] = table[i - 1] + table[i - 2]; // 状态转移
    }
    return table[n];
}
```
**示例：斐波那契数列**
```cpp
int fibonacci(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; ++i) {
        c = a + b;
        a = b; b = c;
    }
    return b;
}
```

#### **3. 回溯模板**
```cpp
void backtrack(参数) {
    if (终止条件) {
        收集结果;
        return;
    }
    for (选择: 本层集合中元素) {
        处理节点; // 做出选择
        backtrack(路径, 选择列表); // 递归
        回溯操作; // 撤销选择
    }
}
```
**示例：全排列**
```cpp
void backtrack(vector<int>& nums, vector<vector<int>>& res, int start) {
    if (start == nums.size()) {
        res.push_back(nums);
        return;
    }
    for (int i = start; i < nums.size(); ++i) {
        swap(nums[start], nums[i]); // 选择
        backtrack(nums, res, start + 1); // 递归
        swap(nums[start], nums[i]); // 撤销选择
    }
}
```

### **三、使用场景对比**

| **算法**   | **典型问题**                                                                 | **特点**                                                                 |
|------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **递归**   | 阶乘、斐波那契数列、汉诺塔、树遍历（前序/中序/后序）、DFS                   | 代码简洁，但可能重复计算，适合问题规模较小或分解过程直观的场景。          |
| **动态规划** | 背包问题、最长公共子序列、最短路径（Dijkstra）、矩阵链乘法、股票买卖问题   | 适合重叠子问题，通过存储子问题解优化时间复杂度（从指数级降为多项式级）。  |
| **回溯**   | 排列、组合、子集、N皇后、数独、全排列、八皇后问题                           | 适合解空间树搜索，通过剪枝减少无效计算，但最坏时间复杂度仍为指数级。      |

### **四、核心区别总结**
1. **递归 vs 动态规划**：
   - 递归是“纯分解”，动态规划是“分解+存储”。
   - 递归可能重复计算，动态规划通过记忆化或填表避免重复。
   - 动态规划要求问题具有最优子结构和重叠子问题，递归无此限制。

2. **递归 vs 回溯**：
   - 回溯是递归的“带剪枝版本”，通过撤销选择和剪枝优化搜索效率。
   - 回溯适用于解空间树（如排列、组合），递归适用于更通用的分解问题。

3. **动态规划 vs 回溯**：
   - 动态规划求最优解（如最大值、最小值），回溯求所有解或满足条件的解。
   - 动态规划时间复杂度通常更低（多项式级），回溯可能为指数级（但通过剪枝优化）。
