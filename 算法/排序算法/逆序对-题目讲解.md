### 逆序对问题

**问题描述**：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。给定一个数组，求出这个数组中的逆序对的总数。

**示例**：
输入: [7, 5, 6, 4]
输出: 5
解释:
逆序对有 (7, 5), (7, 6), (7, 4), (5, 4), (6, 4)

### 解题思路：归并排序

归并排序是一种分治算法，其基本思想是将数组分成两部分，分别排序，然后将两个有序的部分合并。在合并的过程中，我们可以统计逆序对的数量。

**具体步骤**：
1. **分解**：将当前数组分成两个子数组，分别递归地进行排序和统计逆序对。
2. **合并与统计**：在合并两个有序子数组时，统计逆序对的数量。具体来说，如果左子数组的当前元素大于右子数组的当前元素，则左子数组中当前元素及其后面的所有元素都会与右子数组的当前元素构成逆序对。

### 示例讲解

以数组 `[7, 5, 6, 4]` 为例：

1. 初始数组：`[7, 5, 6, 4]`
   - 分成 `[7, 5]` 和 `[6, 4]`
2. 处理左子数组 `[7, 5]`：
   - 分成 `[7]` 和 `[5]`
   - 合并 `[7]` 和 `[5]`：
     - 7 > 5，所以逆序对数量为 1（即 `(7, 5)`），合并后为 `[5, 7]`
3. 处理右子数组 `[6, 4]`：
   - 分成 `[6]` 和 `[4]`
   - 合并 `[6]` 和 `[4]`：
     - 6 > 4，所以逆序对数量为 1（即 `(6, 4)`），合并后为 `[4, 6]`
4. 合并 `[5, 7]` 和 `[4, 6]`：
   - 初始化两个指针 `i` 和 `j` 分别指向 `[5, 7]` 和 `[4, 6]` 的开头。
   - 比较 `5` 和 `4`：
     - 5 > 4，所以 `[5, 7]` 中的 `5` 和 `7` 都与 `4` 构成逆序对，逆序对数量增加 2（即 `(5, 4)` 和 `(7, 4)`）。
     - 将 `4` 放入临时数组，`j` 右移。
   - 比较 `5` 和 `6`：
     - 5 <= 6，将 `5` 放入临时数组，`i` 右移。
   - 比较 `7` 和 `6`：
     - 7 > 6，所以 `[7]` 与 `6` 构成逆序对，逆序对数量增加 1（即 `(7, 6)`）。
     - 将 `6` 放入临时数组，`j` 右移。
   - `[7]` 剩余，直接放入临时数组。
   - 合并后的数组为 `[4, 5, 6, 7]`，总逆序对数量为 1 (左) + 1 (右) + 2 + 1 = 5。

### 代码实现

```python
def reversePairs(nums):
    # 归并排序的辅助函数，返回排序后的数组和逆序对数量
    def merge_sort(nums, left, right):
        if left >= right:
            return 0
        mid = (left + right) // 2
        # 递归处理左右子数组
        count = merge_sort(nums, left, mid) + merge_sort(nums, mid + 1, right)
        # 合并两个有序子数组并统计逆序对
        temp = []
        i, j = left, mid + 1
        while i <= mid and j <= right:
            if nums[i] <= nums[j]:
                temp.append(nums[i])
                i += 1
            else:
                # 左子数组的当前元素大于右子数组的当前元素，构成逆序对
                count += mid - i + 1
                temp.append(nums[j])
                j += 1
        # 将剩余元素加入临时数组
        temp.extend(nums[i:mid + 1])
        temp.extend(nums[j:right + 1])
        # 将临时数组复制回原数组
        nums[left:right + 1] = temp
        return count
    
    return merge_sort(nums, 0, len(nums) - 1)

# 示例
nums = [7, 5, 6, 4]
print(reversePairs(nums))  # 输出: 5
```

### 代码注释

1. **`merge_sort` 函数**：
   - 参数：`nums` 是待排序的数组，`left` 和 `right` 是当前处理的子数组范围。
   - 递归终止条件：`left >= right`，即子数组长度为 1 或 0。
   - 计算中间位置 `mid`，递归处理左子数组 `[left, mid]` 和右子数组 `[mid + 1, right]`。
   - 合并两个有序子数组并统计逆序对数量：
     - 初始化临时数组 `temp` 和两个指针 `i` 和 `j`。
     - 如果 `nums[i] <= nums[j]`，将 `nums[i]` 加入 `temp`，`i` 右移。
     - 如果 `nums[i] > nums[j]`，则 `[i, mid]` 的所有元素都与 `nums[j]` 构成逆序对，数量增加 `mid - i + 1`，将 `nums[j]` 加入 `temp`，`j` 右移。
     - 将剩余元素加入 `temp`。
     - 将 `temp` 复制回 `nums[left:right + 1]`。
   - 返回逆序对数量 `count`。

2. **主函数 `reversePairs`**：
   - 调用 `merge_sort` 对整个数组进行排序和统计。
   - 返回逆序对总数。

### 复杂度分析

- **时间复杂度**：O(n log n)，归并排序的时间复杂度。
- **空间复杂度**：O(n)，临时数组 `temp` 的空间。

这种方法高效地利用了归并排序的分治特性，在合并过程中统计逆序对，避免了暴力解法的 O(n²) 时间复杂度。

--- 
# C++解法

### **C++ 实现：逆序对问题（基于归并排序）**

#### **问题描述**
给定一个数组 `nums`，统计其中的**逆序对**总数。逆序对定义为：如果 `i < j` 且 `nums[i] > nums[j]`，则 `(nums[i], nums[j])` 是一个逆序对。

#### **解题思路（归并排序）**
1. **分治思想**：
   - **分解**：将数组分成两部分，递归计算左半部分和右半部分的逆序对数量。
   - **合并**：在合并两个有序数组时，统计跨左右两部分的逆序对数量。
2. **关键观察**：
   - 在合并两个有序数组 `left` 和 `right` 时，如果 `left[i] > right[j]`，则 `left[i]` 及其后面的所有元素都会与 `right[j]` 构成逆序对（因为 `left` 和 `right` 都是有序的）。
3. **时间复杂度**：
   - **O(n log n)**（归并排序的标准复杂度）。
4. **空间复杂度**：
   - **O(n)**（临时数组 `temp` 的空间）。

---

### **C++ 代码实现**
这里的实现，只是把归并排序的子问题求解的函数，放到dfs函数中了。 也可以dfs函数、子问题求解函数，2个函数分开的写法。
```cpp
#include <vector>
#include <iostream>

using namespace std;

class Solution {
public:
    int reversePairs(vector<int>& nums) {
        vector<int> temp(nums.size()); // 临时数组，用于归并排序
        return mergeSortAndCount(nums, temp, 0, nums.size() - 1);
    }

private:
    int mergeSortAndCount(vector<int>& nums, vector<int>& temp, int left, int right) {
        if (left >= right) {
            return 0; // 单个元素无逆序对
        }

        int mid = left + (right - left) / 2; // 防止溢出
        int count = mergeSortAndCount(nums, temp, left, mid) // 左半部分逆序对
                  + mergeSortAndCount(nums, temp, mid + 1, right); // 右半部分逆序对

        // 合并两个有序数组，并统计跨左右两部分的逆序对
        int i = left, j = mid + 1, k = left;
        while (i <= mid && j <= right) {
            if (nums[i] <= nums[j]) {
                temp[k++] = nums[i++];
            } else {
                // nums[i] > nums[j]，说明 left[i..mid] 都 > nums[j]
                count += mid - i + 1; // 统计逆序对
                temp[k++] = nums[j++];
            }
        }
        // 处理剩余元素
        while (i <= mid) temp[k++] = nums[i++];
        while (j <= right) temp[k++] = nums[j++];
        // 将 temp 复制回 nums
        for (int p = left; p <= right; p++) {
            nums[p] = temp[p];
        }

        return count;
    }
};

int main() {
    vector<int> nums = {7, 5, 6, 4};
    Solution sol;
    cout << "Number of reverse pairs: " << sol.reversePairs(nums) << endl;
    // 输出: 5 (逆序对为 (7,5), (7,6), (7,4), (5,4), (6,4))
    return 0;
}
```

---

### **代码详细解释**
#### **1. `reversePairs` 函数**
- **作用**：主函数，调用 `mergeSortAndCount` 计算逆序对总数。
- **参数**：
  - `nums`：输入数组。
  - `temp`：临时数组，用于归并排序。
- **返回值**：逆序对总数。

#### **2. `mergeSortAndCount` 函数**
- **作用**：递归计算逆序对，并在合并时统计跨左右两部分的逆序对。
- **参数**：
  - `nums`：当前处理的数组。
  - `temp`：临时数组。
  - `left` 和 `right`：当前子数组的范围。
- **返回值**：当前子数组的逆序对总数。

##### **步骤**
1. **递归终止条件**：
   - 如果 `left >= right`，说明子数组长度为 1 或 0，直接返回 0。
2. **递归计算左右两部分的逆序对**：
   - `mergeSortAndCount(nums, temp, left, mid)`
   - `mergeSortAndCount(nums, temp, mid + 1, right)`
3. **合并两个有序数组并统计跨部分的逆序对**：
   - **初始化指针**：
     - `i` 指向左半部分开头（`left`）。
     - `j` 指向右半部分开头（`mid + 1`）。
     - `k` 指向 `temp` 的当前位置。
   - **比较 `nums[i]` 和 `nums[j]`**：
     - 如果 `nums[i] <= nums[j]`，说明 `nums[i]` 不会与右半部分的任何元素构成逆序对，直接放入 `temp`。
     - 如果 `nums[i] > nums[j]`，说明 `nums[i]` 及其后面的所有元素（`left[i..mid]`）都会与 `nums[j]` 构成逆序对，因此 `count += mid - i + 1`。
   - **处理剩余元素**：
     - 如果左半部分还有剩余元素，直接复制到 `temp`。
     - 如果右半部分还有剩余元素，直接复制到 `temp`。
   - **将 `temp` 复制回 `nums`**：
     - 保证 `nums` 在后续递归中是有序的。
4. **返回逆序对总数**：
   - `count` = 左半部分逆序对 + 右半部分逆序对 + 跨部分逆序对。

---

### **示例运行**
**输入**：`[7, 5, 6, 4]`  
**执行流程**：
1. **分解**：
   - `[7, 5, 6, 4]` → `[7, 5]` 和 `[6, 4]`
   - `[7, 5]` → `[7]` 和 `[5]`（逆序对 = 1）
   - `[6, 4]` → `[6]` 和 `[4]`（逆序对 = 1）
2. **合并 `[7]` 和 `[5]`**：
   - `7 > 5` → 逆序对 = 1，合并后 `[5, 7]`
3. **合并 `[6]` 和 `[4]`**：
   - `6 > 4` → 逆序对 = 1，合并后 `[4, 6]`
4. **合并 `[5, 7]` 和 `[4, 6]`**：
   - `5 > 4` → `[5,7]` 的所有元素 > `4` → 逆序对 += 2
   - `7 > 6` → `[7]` > `6` → 逆序对 += 1
   - 最终合并后 `[4, 5, 6, 7]`，总逆序对 = 1 + 1 + 2 + 1 = **5**

**输出**：`5`（逆序对为 `(7,5), (7,6), (7,4), (5,4), (6,4)`）

---

### **总结**
- **归并排序 + 逆序对统计** 是一种高效的 **O(n log n)** 算法。
- **关键点**：
  - 在合并时，如果 `left[i] > right[j]`，则 `left[i..mid]` 的所有元素都会与 `right[j]` 构成逆序对。
- **适用场景**：
  - 大数据量下的逆序对统计（比暴力解法 **O(n²)** 更高效）。
